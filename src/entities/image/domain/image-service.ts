import {
  Image,
  CreateImageData,
  UpdateImageData,
  ImageFilters,
  ImageListResult,
  PaginationOptions,
  UploadMetadata,
} from "./image";
import { ProductImage, CreateProductImageData } from "./product-image";
import { DropImage, CreateDropImageData } from "./drop-image";
import { PrismaImageRepository } from "../infrastructure/image-repository";
import {
  Result,
  ValidationError,
  NotFoundError,
  ConflictError,
} from "../../../lib/domain";
import {
  CreateImageDataSchema,
  UpdateImageDataSchema,
  CreateProductImageDataSchema,
  CreateDropImageDataSchema,
} from "../../../lib/schemas/image-schema";
import { prisma } from "../../../lib/db";

export interface ImageServiceDependencies {
  imageRepository: PrismaImageRepository;
  prisma: any; // Using any for now to avoid type issues - will be the actual prisma client
}

export class ImageService implements IImageService {
  constructor(private readonly deps: ImageServiceDependencies) {}

  /**
   * Create a new image with business rule validation
   */
  async create(data: CreateImageData): Promise<Result<Image>> {
    try {
      // Validate input data using Zod schema
      const validationResult = CreateImageDataSchema.safeParse(data);
      if (!validationResult.success) {
        return {
          success: false,
          error: new ValidationError(
            validationResult.error.issues.map((e) => e.message).join(", ")
          ),
        };
      }

      const validData = validationResult.data;

      // Validate business rules using domain entity
      const domainValidation = Image.validateCreateData(validData);
      if (!domainValidation.isValid) {
        return {
          success: false,
          error: new ValidationError(domainValidation.errors.join(", ")),
        };
      }

      // Check if category exists if provided
      if (validData.categoryId) {
        const categoryExists = await this.deps.prisma.imageCategory.findUnique({
          where: { id: validData.categoryId },
        });
        if (!categoryExists || !categoryExists.isActive) {
          return {
            success: false,
            error: new ValidationError(
              "Image category does not exist or is inactive"
            ),
          };
        }
      }

      // Check for duplicate filename for same uploader
      const existingImage = await this.deps.prisma.image.findFirst({
        where: {
          filename: validData.filename,
          uploadedBy: validData.uploadedBy,
          isActive: true,
        },
      });

      if (existingImage) {
        return {
          success: false,
          error: new ConflictError(
            "An active image with this filename already exists for this user"
          ),
        };
      }

      // Create image using domain entity
      const image = new Image(
        "", // ID will be generated by database
        validData.title,
        validData.altText,
        validData.url,
        validData.thumbUrl,
        validData.deleteUrl,
        validData.filename,
        validData.originalName,
        validData.size,
        validData.mimeType,
        validData.width,
        validData.height,
        validData.uploadedBy,
        validData.categoryId
          ? { id: validData.categoryId, name: "" }
          : undefined,
        validData.tags || [],
        validData.isPublic,
        true // isActive defaults to true
      );

      const createdImage = await this.deps.imageRepository.create(image);

      return { success: true, data: createdImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to create image: ${error.message}`),
      };
    }
  }

  /**
   * Get image by ID
   */
  async getById(id: string): Promise<Result<Image>> {
    try {
      const image = await this.deps.imageRepository.findById(id);
      if (!image) {
        return {
          success: false,
          error: new NotFoundError("Image", id),
        };
      }

      return { success: true, data: image };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get image: ${error.message}`),
      };
    }
  }

  /**
   * Update image with business rule validation
   */
  async update(id: string, data: UpdateImageData): Promise<Result<Image>> {
    try {
      // Validate input data using Zod schema
      const validationResult = UpdateImageDataSchema.safeParse(data);
      if (!validationResult.success) {
        return {
          success: false,
          error: new ValidationError(
            validationResult.error.issues.map((e) => e.message).join(", ")
          ),
        };
      }

      const validData = validationResult.data;

      // Check if image exists
      const existingImage = await this.deps.imageRepository.findById(id);
      if (!existingImage) {
        return {
          success: false,
          error: new NotFoundError("Image", id),
        };
      }

      // Validate business rules using domain entity
      const updateResult = existingImage.updateDetails(validData);
      if (!updateResult.success) {
        return updateResult;
      }

      // Check if category exists if being updated
      if (validData.categoryId) {
        const categoryExists = await this.deps.prisma.imageCategory.findUnique({
          where: { id: validData.categoryId },
        });
        if (!categoryExists || !categoryExists.isActive) {
          return {
            success: false,
            error: new ValidationError(
              "Image category does not exist or is inactive"
            ),
          };
        }
      }

      // Update image
      const updatedImage = await this.deps.imageRepository.update(
        id,
        validData
      );

      return { success: true, data: updatedImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to update image: ${error.message}`),
      };
    }
  }

  /**
   * Delete image (soft delete by deactivating)
   */
  async delete(id: string): Promise<Result<boolean>> {
    try {
      // Check if image exists
      const existingImage = await this.deps.imageRepository.findById(id);
      if (!existingImage) {
        return {
          success: false,
          error: new NotFoundError("Image", id),
        };
      }

      // Check if image is associated with products or drops
      const productAssociations = await this.deps.prisma.productImage.count({
        where: { imageId: id },
      });

      const dropAssociations = await this.deps.prisma.dropImage.count({
        where: { imageId: id },
      });

      if (productAssociations > 0 || dropAssociations > 0) {
        return {
          success: false,
          error: new ValidationError(
            "Cannot delete image that is associated with products or drops. Remove associations first."
          ),
        };
      }

      // Soft delete by deactivating
      await this.deps.imageRepository.update(id, { isActive: false });

      return { success: true, data: true };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to delete image: ${error.message}`),
      };
    }
  }

  /**
   * Get multiple images
   */
  async getMany(criteria?: Partial<Image>): Promise<Result<Image[]>> {
    try {
      const images = await this.deps.imageRepository.findMany(criteria);
      return { success: true, data: images };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get images: ${error.message}`),
      };
    }
  }

  /**
   * Upload image (enhanced create method)
   */
  async uploadImage(
    file: File,
    uploaderId: string,
    metadata?: UploadMetadata
  ): Promise<Result<Image>> {
    try {
      // Validate file
      if (!file) {
        return {
          success: false,
          error: new ValidationError("No file provided"),
        };
      }

      // Validate file type
      const validTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"];
      if (!validTypes.includes(file.type)) {
        return {
          success: false,
          error: new ValidationError(
            "Invalid file type. Only JPEG, PNG, WebP, and GIF are allowed"
          ),
        };
      }

      // Validate file size (10MB limit)
      if (file.size > 10 * 1024 * 1024) {
        return {
          success: false,
          error: new ValidationError("File size cannot exceed 10MB"),
        };
      }

      // Generate URLs (in a real implementation, these would be uploaded to a storage service)
      const filename = `${Date.now()}-${file.name.replace(
        /[^a-zA-Z0-9.-]/g,
        "_"
      )}`;
      const url = `/uploads/${filename}`;
      const thumbUrl = `/uploads/thumbnails/${filename}`;

      const createData: CreateImageData = {
        filename,
        originalName: file.name,
        size: file.size,
        mimeType: file.type,
        url,
        thumbUrl,
        uploadedBy: uploaderId,
        categoryId: metadata?.categoryId,
        tags: metadata?.tags,
        isPublic: metadata?.isPublic ?? true,
      };

      return await this.create(createData);
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to upload image: ${error.message}`),
      };
    }
  }

  /**
   * Delete image with ownership validation
   */
  async deleteImage(id: string, userId: string): Promise<Result<boolean>> {
    try {
      // Check if image exists and user owns it
      const existingImage = await this.deps.imageRepository.findById(id);
      if (!existingImage) {
        return {
          success: false,
          error: new NotFoundError("Image", id),
        };
      }

      if (existingImage.uploadedBy !== userId) {
        return {
          success: false,
          error: new ValidationError("You can only delete your own images"),
        };
      }

      return await this.delete(id);
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to delete image: ${error.message}`),
      };
    }
  }

  /**
   * Get images by uploader with pagination
   */
  async getImagesByUploader(
    uploaderId: string,
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>> {
    try {
      const result = await this.deps.imageRepository.findByUploader(
        uploaderId,
        filters,
        pagination
      );

      const totalPages = pagination?.limit
        ? Math.ceil(result.total / pagination.limit)
        : 1;

      const imageListResult: ImageListResult = {
        images: result.images,
        total: result.total,
        page: pagination?.page || 1,
        limit: pagination?.limit || result.images.length,
        totalPages,
      };

      return { success: true, data: imageListResult };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get images by uploader: ${error.message}`),
      };
    }
  }

  /**
   * Get public images with pagination
   */
  async getPublicImages(
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>> {
    try {
      const result = await this.deps.imageRepository.findPublic(
        filters,
        pagination
      );

      const totalPages = pagination?.limit
        ? Math.ceil(result.total / pagination.limit)
        : 1;

      const imageListResult: ImageListResult = {
        images: result.images,
        total: result.total,
        page: pagination?.page || 1,
        limit: pagination?.limit || result.images.length,
        totalPages,
      };

      return { success: true, data: imageListResult };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get public images: ${error.message}`),
      };
    }
  }

  /**
   * Associate image with product
   */
  async associateWithProduct(
    imageId: string,
    productId: string,
    isPrimary: boolean = false
  ): Promise<Result<ProductImage>> {
    try {
      // Validate input data
      const validationResult = CreateProductImageDataSchema.safeParse({
        productId,
        imageId,
        isPrimary,
      });
      if (!validationResult.success) {
        return {
          success: false,
          error: new ValidationError(
            validationResult.error.issues.map((e) => e.message).join(", ")
          ),
        };
      }

      // Check if image exists
      const image = await this.deps.imageRepository.findById(imageId);
      if (!image) {
        return {
          success: false,
          error: new NotFoundError("Image", imageId),
        };
      }

      // Check if product exists
      const product = await this.deps.prisma.product.findUnique({
        where: { id: productId },
      });
      if (!product) {
        return {
          success: false,
          error: new NotFoundError("Product", productId),
        };
      }

      // Check if association already exists
      const existingAssociation =
        await this.deps.prisma.productImage.findUnique({
          where: {
            productId_imageId: {
              productId,
              imageId,
            },
          },
        });

      if (existingAssociation) {
        return {
          success: false,
          error: new ConflictError(
            "Image is already associated with this product"
          ),
        };
      }

      // If setting as primary, remove existing primary associations
      if (isPrimary) {
        await this.deps.prisma.productImage.updateMany({
          where: { productId, isPrimary: true },
          data: { isPrimary: false },
        });
      }

      // Create association
      const association = await this.deps.prisma.productImage.create({
        data: {
          productId,
          imageId,
          isPrimary,
        },
      });

      const productImage = new ProductImage(
        association.id,
        association.productId,
        association.imageId,
        association.sortOrder,
        association.isPrimary,
        new Date(association.createdAt),
        new Date(association.updatedAt)
      );

      return { success: true, data: productImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(
          `Failed to associate image with product: ${error.message}`
        ),
      };
    }
  }

  /**
   * Remove image from product
   */
  async removeFromProduct(
    imageId: string,
    productId: string
  ): Promise<Result<boolean>> {
    try {
      // Check if association exists
      const association = await this.deps.prisma.productImage.findUnique({
        where: {
          productId_imageId: {
            productId,
            imageId,
          },
        },
      });

      if (!association) {
        return {
          success: false,
          error: new NotFoundError("Product image association"),
        };
      }

      // Delete association
      await this.deps.prisma.productImage.delete({
        where: {
          productId_imageId: {
            productId,
            imageId,
          },
        },
      });

      return { success: true, data: true };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(
          `Failed to remove image from product: ${error.message}`
        ),
      };
    }
  }

  /**
   * Associate image with drop
   */
  async associateWithDrop(
    imageId: string,
    dropId: string,
    caption?: string
  ): Promise<Result<DropImage>> {
    try {
      // Validate input data
      const validationResult = CreateDropImageDataSchema.safeParse({
        dropId,
        imageId,
        caption,
      });
      if (!validationResult.success) {
        return {
          success: false,
          error: new ValidationError(
            validationResult.error.issues.map((e) => e.message).join(", ")
          ),
        };
      }

      // Check if image exists
      const image = await this.deps.imageRepository.findById(imageId);
      if (!image) {
        return {
          success: false,
          error: new NotFoundError("Image", imageId),
        };
      }

      // Check if drop exists
      const drop = await this.deps.prisma.drop.findUnique({
        where: { id: dropId },
      });
      if (!drop) {
        return {
          success: false,
          error: new NotFoundError("Drop", dropId),
        };
      }

      // Check if association already exists
      const existingAssociation = await this.deps.prisma.dropImage.findUnique({
        where: {
          dropId_imageId: {
            dropId,
            imageId,
          },
        },
      });

      if (existingAssociation) {
        return {
          success: false,
          error: new ConflictError(
            "Image is already associated with this drop"
          ),
        };
      }

      // Create association
      const association = await this.deps.prisma.dropImage.create({
        data: {
          dropId,
          imageId,
          caption,
        },
      });

      const dropImage = new DropImage(
        association.id,
        association.dropId,
        association.imageId,
        association.sortOrder,
        association.caption,
        new Date(association.createdAt),
        new Date(association.updatedAt)
      );

      return { success: true, data: dropImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(
          `Failed to associate image with drop: ${error.message}`
        ),
      };
    }
  }

  /**
   * Remove image from drop
   */
  async removeFromDrop(
    imageId: string,
    dropId: string
  ): Promise<Result<boolean>> {
    try {
      // Check if association exists
      const association = await this.deps.prisma.dropImage.findUnique({
        where: {
          dropId_imageId: {
            dropId,
            imageId,
          },
        },
      });

      if (!association) {
        return {
          success: false,
          error: new NotFoundError("Drop image association"),
        };
      }

      // Delete association
      await this.deps.prisma.dropImage.delete({
        where: {
          dropId_imageId: {
            dropId,
            imageId,
          },
        },
      });

      return { success: true, data: true };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to remove image from drop: ${error.message}`),
      };
    }
  }

  /**
   * Get product images
   */
  async getProductImages(productId: string): Promise<Result<Image[]>> {
    try {
      // Check if product exists
      const product = await this.deps.prisma.product.findUnique({
        where: { id: productId },
      });

      if (!product) {
        return {
          success: false,
          error: new NotFoundError("Product", productId),
        };
      }

      // Get associated images
      const associations = await this.deps.prisma.productImage.findMany({
        where: { productId },
        include: {
          image: {
            include: {
              uploader: {
                select: {
                  id: true,
                  username: true,
                  email: true,
                },
              },
              category: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
        },
        orderBy: [{ isPrimary: "desc" }, { sortOrder: "asc" }],
      });

      const images = associations.map((assoc: any) => assoc.image);

      return { success: true, data: images };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get product images: ${error.message}`),
      };
    }
  }

  /**
   * Get drop images
   */
  async getDropImages(dropId: string): Promise<Result<Image[]>> {
    try {
      // Check if drop exists
      const drop = await this.deps.prisma.drop.findUnique({
        where: { id: dropId },
      });

      if (!drop) {
        return {
          success: false,
          error: new NotFoundError("Drop", dropId),
        };
      }

      // Get associated images
      const associations = await this.deps.prisma.dropImage.findMany({
        where: { dropId },
        include: {
          image: {
            include: {
              uploader: {
                select: {
                  id: true,
                  username: true,
                  email: true,
                },
              },
              category: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
        },
        orderBy: { sortOrder: "asc" },
      });

      const images = associations.map((assoc: any) => assoc.image);

      return { success: true, data: images };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get drop images: ${error.message}`),
      };
    }
  }

  /**
   * Search images
   */
  async searchImages(
    query: string,
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>> {
    try {
      const result = await this.deps.imageRepository.search(query, pagination);

      // Apply additional filters if provided
      let filteredImages = result.images;
      if (filters) {
        filteredImages = filteredImages.filter((image) => {
          if (filters.uploadedBy && image.uploadedBy !== filters.uploadedBy)
            return false;
          if (filters.categoryId && image.category?.id !== filters.categoryId)
            return false;
          if (filters.tags && filters.tags.length > 0) {
            const imageTags = image.tags || [];
            if (!filters.tags.some((tag) => imageTags.includes(tag)))
              return false;
          }
          if (
            filters.isPublic !== undefined &&
            image.isPublic !== filters.isPublic
          )
            return false;
          if (
            filters.isActive !== undefined &&
            image.isActive !== filters.isActive
          )
            return false;
          if (filters.mimeType && image.mimeType !== filters.mimeType)
            return false;
          if (filters.minSize && image.size < filters.minSize) return false;
          if (filters.maxSize && image.size > filters.maxSize) return false;
          return true;
        });
      }

      // Apply pagination to filtered results
      const startIndex = pagination
        ? (pagination.page! - 1) * pagination.limit!
        : 0;
      const endIndex = pagination
        ? startIndex + pagination.limit!
        : filteredImages.length;
      const paginatedImages = filteredImages.slice(startIndex, endIndex);

      const totalPages = pagination?.limit
        ? Math.ceil(filteredImages.length / pagination.limit)
        : 1;

      const imageListResult: ImageListResult = {
        images: paginatedImages,
        total: filteredImages.length,
        page: pagination?.page || 1,
        limit: pagination?.limit || filteredImages.length,
        totalPages,
      };

      return { success: true, data: imageListResult };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to search images: ${error.message}`),
      };
    }
  }

  /**
   * Get images by category
   */
  async getImagesByCategory(
    categoryId: string,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>> {
    try {
      const result = await this.deps.imageRepository.findByCategory(
        categoryId,
        pagination
      );

      const totalPages = pagination?.limit
        ? Math.ceil(result.total / pagination.limit)
        : 1;

      const imageListResult: ImageListResult = {
        images: result.images,
        total: result.total,
        page: pagination?.page || 1,
        limit: pagination?.limit || result.images.length,
        totalPages,
      };

      return { success: true, data: imageListResult };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get images by category: ${error.message}`),
      };
    }
  }

  /**
   * Get images by tags
   */
  async getImagesByTags(
    tags: string[],
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>> {
    try {
      const result = await this.deps.imageRepository.findByTags(
        tags,
        pagination
      );

      const totalPages = pagination?.limit
        ? Math.ceil(result.total / pagination.limit)
        : 1;

      const imageListResult: ImageListResult = {
        images: result.images,
        total: result.total,
        page: pagination?.page || 1,
        limit: pagination?.limit || result.images.length,
        totalPages,
      };

      return { success: true, data: imageListResult };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get images by tags: ${error.message}`),
      };
    }
  }

  /**
   * Activate image
   */
  async activate(id: string): Promise<Result<Image>> {
    try {
      const updatedImage = await this.deps.imageRepository.update(id, {
        isActive: true,
      });

      return { success: true, data: updatedImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to activate image: ${error.message}`),
      };
    }
  }

  /**
   * Deactivate image
   */
  async deactivate(id: string): Promise<Result<Image>> {
    try {
      const updatedImage = await this.deps.imageRepository.update(id, {
        isActive: false,
      });

      return { success: true, data: updatedImage };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to deactivate image: ${error.message}`),
      };
    }
  }

  /**
   * Get image statistics
   */
  async getImageStats(): Promise<Result<any>> {
    try {
      const [
        totalImages,
        publicImages,
        privateImages,
        imagesByCategory,
        imagesByType,
        totalSize,
        recentImages,
      ] = await Promise.all([
        this.deps.prisma.image.count(),
        this.deps.prisma.image.count({ where: { isPublic: true } }),
        this.deps.prisma.image.count({ where: { isPublic: false } }),
        this.deps.prisma.image.groupBy({
          by: ["categoryId"],
          _count: { id: true },
          where: { categoryId: { not: null } },
        }),
        this.deps.prisma.image.groupBy({
          by: ["mimeType"],
          _count: { id: true },
        }),
        this.deps.prisma.image.aggregate({
          _sum: { size: true },
        }),
        this.deps.prisma.image.findMany({
          take: 10,
          orderBy: { createdAt: "desc" },
          include: {
            uploader: {
              select: {
                id: true,
                username: true,
                email: true,
              },
            },
            category: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        }),
      ]);

      const stats = {
        totalImages,
        publicImages,
        privateImages,
        totalSize: totalSize._sum.size || 0,
        imagesByCategory: imagesByCategory.reduce((acc: Record<string, number>, item: any) => {
          acc[item.categoryId] = item._count.id;
          return acc;
        }, {} as Record<string, number>),
        imagesByType: imagesByType.reduce((acc: Record<string, number>, item: any) => {
          acc[item.mimeType] = item._count.id;
          return acc;
        }, {} as Record<string, number>),
        recentImages,
      };

      return { success: true, data: stats };
    } catch (error: any) {
      return {
        success: false,
        error: new Error(`Failed to get image statistics: ${error.message}`),
      };
    }
  }
}

// Export the interface from the service file for consistency
export interface IImageService {
  create(data: CreateImageData): Promise<Result<Image>>;
  getById(id: string): Promise<Result<Image>>;
  update(id: string, data: UpdateImageData): Promise<Result<Image>>;
  delete(id: string): Promise<Result<boolean>>;
  getMany(criteria?: Partial<Image>): Promise<Result<Image[]>>;
  uploadImage(
    file: File,
    uploaderId: string,
    metadata?: UploadMetadata
  ): Promise<Result<Image>>;
  deleteImage(id: string, userId: string): Promise<Result<boolean>>;
  getImagesByUploader(
    uploaderId: string,
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>>;
  getPublicImages(
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>>;
  associateWithProduct(
    imageId: string,
    productId: string,
    isPrimary?: boolean
  ): Promise<Result<ProductImage>>;
  removeFromProduct(
    imageId: string,
    productId: string
  ): Promise<Result<boolean>>;
  associateWithDrop(
    imageId: string,
    dropId: string,
    caption?: string
  ): Promise<Result<DropImage>>;
  removeFromDrop(imageId: string, dropId: string): Promise<Result<boolean>>;
  getProductImages(productId: string): Promise<Result<Image[]>>;
  getDropImages(dropId: string): Promise<Result<Image[]>>;
  searchImages(
    query: string,
    filters?: ImageFilters,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>>;
  getImagesByCategory(
    categoryId: string,
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>>;
  getImagesByTags(
    tags: string[],
    pagination?: PaginationOptions
  ): Promise<Result<ImageListResult>>;
  activate(id: string): Promise<Result<Image>>;
  deactivate(id: string): Promise<Result<Image>>;
  getImageStats(): Promise<Result<any>>;
}
